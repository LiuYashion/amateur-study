# 事件巴士
其实也是发布订阅模式


### Reflect对象
看看他的作用
- 代替Object
- 合理化了Object的一些调用
- 使得对Obejct的操作都变成了函数行为

看看他的方法，都是关于对象的操作
```js
Reflect.apply(target, thisArg, args)
Reflect.construct(target, args)
Reflect.get(target, name, receiver)
Reflect.set(target, name, value, receiver)
Reflect.defineProperty(target, name, desc)
Reflect.deleteProperty(target, name)
Reflect.has(target, name)
Reflect.ownKeys(target)
Reflect.isExtensible(target)
Reflect.preventExtensions(target)
Reflect.getOwnPropertyDescriptor(target, name)
Reflect.getPrototypeOf(target)
Reflect.setPrototypeOf(target, prototype)
```

**Reflect的意义**
> 他是为了Proxy准备的，call和apply是Function原型上的方法，被改写了就会影响到后续使用。Reflect更加底层，他是不会受到改写的影响


### 基本构造

```js
class EventEmeitter {
  constructor() {
    // 存储事件
    this._events = this._events || new Map()
    // 设置监听上限
    this._maxListener = this._maxListener || 10
  }
}
```
