# 派发更新
前面我们完成了依赖收集，现在我们来看看派发更新
```js
// 针对每个data，都会做一次
data {
  getter: {
    Dep: {
      subs: [
        watcher1(vm, updateComponent),
        watcher2(vm, updateComponent),
        watcher3(vm, updateComponent)
      ],
      notify() {
        const subs = this.subs.slice()
        for (let i = 0, l = subs.length; i < l; i++) {
          subs[i].update()
        }
      }
    }
  }
}
```
我们来看看watcher对象
```js
watcher {
  update() {
    if (this.computed) {
      if (this.dep.subs.length === 0) {
        this.dirty = true
      } else {
        this.getAndInvoke(() => {
          this.dep.notify()
        })
      }
    } else if (this.sync) {
      this.run()
    } else {
      /**
       * 这种情况下：
       * 每次update就把watcher添加到一个队列中
       * 然后在nextTick之后再执行flushSchedulerQueue
       */
      queueWatcher(this)
    }
  }
}
```
