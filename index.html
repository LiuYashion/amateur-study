<head>    
<title></title>    
<meta http-equiv="Content-Type" content="text/html" ; charset="UTF-8">    
<script language="javascript">  


    /**
     *  实现apply
     *  Fun.apply(this)
     */
    Function.prototype._apply = function(context){
        context.fn = this;
        arguments[1] != undefined ? context.fn(...arguments[1]) : context.fn();
        delete context.fn;
    }
    /**
     *  实现bind
     *  Fun.bind(this)
     */
    Function.prototype._bind = function(context){
        var result = [...arguments].slice(1)
        let target = this;
        return function(){
            return target._apply(context, result)
        }
    }

    var child = { name: 'Nick' }
    function speak(pro, school){
        console.log(`My name is ${this.name}, I'm from ${pro} —— ${school}`)
    }

    speak._apply(child, ['ShenZhen', 'First Senior School'])
    speak._bind(child, 'ShenZhen', 'First Senior School')()


    /**
     *  bind的科里化 
     *  将使用多个参数的函数，转换为一系列使用单个参数的函数
     */
    // add(1, 2) // 3
    // addCurry(1)(2) // 3

    //  那么科里化到底有什么好处呢
    //  参数复用。本质上是降低通用性，提高适用性

    // 第三版
    function curry(fn, args, holes) {
        length = fn.length;

        args = args || [];

        holes = holes || [];

        return function() {

            var _args = args.slice(0),
                _holes = holes.slice(0),
                argsLen = args.length,
                holesLen = holes.length,
                arg, i, index = 0;

            for (i = 0; i < arguments.length; i++) {
                arg = arguments[i];
                // 处理类似 fn(1, _, _, 4)(_, 3) 这种情况，index 需要指向 holes 正确的下标
                if (arg === _ && holesLen) {
                    index++
                    if (index > holesLen) {
                        _args.push(arg);
                        _holes.push(argsLen - 1 + index - holesLen)
                    }
                }
                // 处理类似 fn(1)(_) 这种情况
                else if (arg === _) {
                    _args.push(arg);
                    _holes.push(argsLen + i);
                }
                // 处理类似 fn(_, 2)(1) 这种情况
                else if (holesLen) {
                    // fn(_, 2)(_, 3)
                    if (index >= holesLen) {
                        _args.push(arg);
                    }
                    // fn(_, 2)(1) 用参数 1 替换占位符
                    else {
                        _args.splice(_holes[index], 1, arg);
                        _holes.splice(index, 1)
                    }
                }
                else {
                    _args.push(arg);
                }

            }
            if (_holes.length || _args.length < length) {
                return curry.call(this, fn, _args, _holes);
            }
            else {
                return fn.apply(this, _args);
            }
        }
    }

    var _ = {};

    var fn = curry(function(a, b, c, d, e) {
        console.log([a, b, c, d, e]);
    });

    // 验证 输出全部都是 [1, 2, 3, 4, 5]
    fn(1, 2, 3, 4, 5);
    fn(_, 2, 3, 4, 5)(1);
    fn(1, _, 3, 4, 5)(2);
    fn(1, _, 3)(_, 4)(2)(5);
    fn(1, _, _, 4)(_, 3)(2)(5);
    fn(_, 2)(_, _, 4)(1)(3)(5)

    // https://juejin.im/post/5af13664f265da0ba266efcf

    let test = a => b => c => {xxx}
    test(a)(b)(c)
    // 比如对于上面的 test 函数，它有 3 个箭头， 这个函数要被调用 3 次 test(a)(b)(c)，前两次调用只是在传递参数，只有最后依次调用才会返回 {xxx} 代码段的返回值，并且在 {xxx} 代码段中可以使用 a,b,c
    
</script>    
</head>